name: SSH Deploy
description: Deploy to the production server over SSH with cleanup, network setup, and Docker Compose
inputs:
  host:
    description: Production host
    required: true
  user:
    description: SSH username
    required: true
  port:
    description: SSH port
    required: true
  ssh_key:
    description: SSH private key (ed25519)
    required: true
  ghcr_username:
    description: GHCR username
    required: true
  ghcr_token:
    description: GHCR token
    required: true
  repository:
    description: owner/repo for images
    required: true
  sha:
    description: Git SHA to deploy
    required: true
runs:
  using: composite
  steps:
    - name: Configure SSH
      shell: bash
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        # Support both raw OpenSSH key and base64-encoded key in secret
        KEY_RAW="${{ inputs.ssh_key }}"
        # Detect plaintext OpenSSH key; use -- to prevent grep from treating dashes as options
        if printf "%s" "$KEY_RAW" | grep -q -- "BEGIN OPENSSH PRIVATE KEY"; then
          # Looks like a PEM/OpenSSH key; normalize newlines
          printf "%s" "$KEY_RAW" | sed 's/\\n/\n/g' > ~/.ssh/id_ed25519
        else
          # Try base64 decode first; fallback to literal write if decode fails
          printf "%s" "$KEY_RAW" | tr -d '\r' | base64 -d > ~/.ssh/id_ed25519 2>/dev/null || true
          if ! grep -q -- "BEGIN OPENSSH PRIVATE KEY" ~/.ssh/id_ed25519 2>/dev/null; then
            printf "%s" "$KEY_RAW" | sed 's/\\n/\n/g' > ~/.ssh/id_ed25519
          fi
        fi
        chmod 600 ~/.ssh/id_ed25519
        # Quick validation/warning if the key is passphrase-protected or invalid
        if ! ssh-keygen -y -f ~/.ssh/id_ed25519 >/dev/null 2>&1; then
          echo "WARNING: SSH key appears invalid or passphrase-protected. Ensure an unencrypted OpenSSH ed25519 private key is provided in secrets." >&2
          echo "Key header (first line): $(head -n1 ~/.ssh/id_ed25519 2>/dev/null || echo 'N/A')" >&2
        fi
        # Best-effort host key prefetch; do not fail if host is unreachable
        ssh-keyscan -T 10 -p "${{ inputs.port }}" "${{ inputs.host }}" >> ~/.ssh/known_hosts 2>/dev/null || true

    - name: Sync deployment files to server
      shell: bash
      run: |
        HOST_RAW='${{ inputs.host }}'
        USER_RAW='${{ inputs.user }}'
        PORT_RAW='${{ inputs.port }}'
        HOST=$(printf "%s" "$HOST_RAW" | tr -d ' \t\r\n')
        USER=$(printf "%s" "$USER_RAW" | tr -d ' \t\r\n')
        PORT=$(printf "%s" "$PORT_RAW" | tr -d ' \t\r\n')
        if [ -z "$PORT" ]; then PORT=22; fi
        SSH_OPTS="-4 -i ~/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=60 -o ConnectionAttempts=3 -o ServerAliveInterval=15 -o ServerAliveCountMax=4 -o PreferredAuthentications=publickey -o PubkeyAuthentication=yes -o IPQoS=none"
        echo "Syncing infrastructure/ to server..."
        tar -czf - infrastructure | \
          ssh $SSH_OPTS -p "$PORT" "$USER@$HOST" \
          "mkdir -p ~/personal-website && tar -xzf - -C ~/personal-website"

    - name: Deploy over SSH
      shell: bash
      run: |
        HOST_RAW='${{ inputs.host }}'
        USER_RAW='${{ inputs.user }}'
        PORT_RAW='${{ inputs.port }}'
        HOST=$(printf "%s" "$HOST_RAW" | tr -d ' \t\r\n')
        USER=$(printf "%s" "$USER_RAW" | tr -d ' \t\r\n')
        PORT=$(printf "%s" "$PORT_RAW" | tr -d ' \t\r\n')
        if [ -z "$PORT" ]; then PORT=22; fi

        echo "Resolving host: $HOST"
        (getent hosts "$HOST" || nslookup -timeout=5 "$HOST" || dig +short "$HOST") 2>/dev/null || true

        echo "Checking TCP connectivity to $HOST:$PORT"
        if command -v nc >/dev/null 2>&1; then
          nc -zv -w 10 "$HOST" "$PORT" || true
        else
          (echo > "/dev/tcp/$HOST/$PORT") >/dev/null 2>&1 || true
        fi

        # Prepare remote script once, then stream it to SSH (allows retries)
        # Use single-quoted heredoc so shell vars like $HOME, $DOMAIN_NAME expand on remote side
        cat > /tmp/remote_deploy.sh << 'RSCRIPT'
        set -euo pipefail
        cd "$HOME/personal-website"

        # Validate required environment variables are present
        : "${GHCR_TOKEN:?missing GHCR_TOKEN}"
        : "${GHCR_USERNAME:?missing GHCR_USERNAME}"
        : "${REPO:?missing REPO}"
        : "${SHA:?missing SHA}"

        echo "Disk usage before cleanup:" && df -h /
        echo "Docker disk usage before cleanup:" && docker system df || true

        DOCKER_CONFIG_DIR="$(mktemp -d -t docker-config-XXXXXX 2>/dev/null || echo /tmp/docker-config)"
        export DOCKER_CONFIG="$DOCKER_CONFIG_DIR"
        # Use environment variables passed from SSH command
        echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
        trap 'rm -rf "$DOCKER_CONFIG_DIR"' EXIT

        export WORKFOLIO_IMAGE=ghcr.io/$REPO/workfolio:$SHA

        # Note: rely on compose pull/up --pull always; no manual docker pull here

        if [ -f infrastructure/prod/.env ]; then
          echo "Loading environment from infrastructure/prod/.env"
          set -a
          while IFS= read -r line || [ -n "$line" ]; do
            case "$line" in ''|\#*) continue ;; esac
            printf '%s' "$line" | grep -Eq '^[A-Za-z_][A-Za-z0-9_]*=' || continue
            export "$line"
          done < infrastructure/prod/.env
          set +a
        else
          echo "WARNING: infrastructure/prod/.env not found; continuing without extra env" >&2
        fi

        # If TLS certs are missing, obtain them via standalone certbot (binds to host :80)
        if [ -z "${DOMAIN_NAME:-}" ]; then
          echo "ERROR: DOMAIN_NAME is required in infrastructure/prod/.env" >&2
          exit 1
        fi
        DOMAIN_NAME_VALUE="$DOMAIN_NAME"
        SSL_EMAIL_VALUE=${SSL_EMAIL:-${USER}@localhost}
        CERT_PATH_HOST="$(pwd)/infrastructure/nginx/ssl/live/${DOMAIN_NAME_VALUE}/fullchain.pem"
        if [ ! -f "$CERT_PATH_HOST" ]; then
          echo "TLS certificates for ${DOMAIN_NAME_VALUE} not found. Attempting standalone certbot issuance..."
          # Ensure directories exist
          mkdir -p infrastructure/nginx/ssl
          mkdir -p infrastructure/nginx/certbot/www
          # Stop any service bound to :80 to free the port (best effort)
          (docker ps --format '{{.ID}} {{.Ports}} {{.Names}}' | grep -E ':80->|:80/' | awk '{print $1}' | xargs -r docker stop) || true
          # Run certbot in standalone mode to write into our ssl mount
          docker run --rm -p 80:80 \
            -v "$(pwd)/infrastructure/nginx/ssl:/etc/letsencrypt" \
            certbot/certbot:latest certonly --standalone \
            -d "$DOMAIN_NAME_VALUE" -m "$SSL_EMAIL_VALUE" \
            --agree-tos --no-eff-email --non-interactive --preferred-challenges http || {
              echo "ERROR: Certbot issuance failed. Check DNS A record points to this server and port 80 is reachable." >&2
              exit 1
            }
          echo "Certificate obtained for ${DOMAIN_NAME_VALUE}."
        else
          echo "Found existing TLS certificate at $CERT_PATH_HOST"
        fi

        echo "Preflight: required config files"
        test -f infrastructure/nginx/nginx.conf
        test -f infrastructure/monitoring/prometheus/prometheus.yml

        docker network create portfolio-network-prod >/dev/null 2>&1 || true
        # Override to force images (and null-out any build) so server never builds locally
        cat > /tmp/compose.images.override.yml << 'IMG'
        services:
          workfolio:
            build: null
            image: ${WORKFOLIO_IMAGE}
        IMG

        cat > /tmp/compose.network.override.yml << 'OVR'
        networks:
          portfolio-network-prod:
            external: true
            name: portfolio-network-prod
        OVR

        if command -v docker-compose >/dev/null 2>&1; then COMPOSE_CMD="docker-compose"; else COMPOSE_CMD="docker compose"; fi
        # Bring stack down with same overrides to prevent name conflicts and stale containers
        $COMPOSE_CMD -f infrastructure/docker-compose.yml -f infrastructure/prod/docker-compose.prod.yml -f infrastructure/prod/docker-compose.monitoring.prod.yml -f /tmp/compose.images.override.yml -f /tmp/compose.network.override.yml down --remove-orphans || true
        # Extra safety: remove any lingering conflicting containers by explicit names
        docker rm -f portfolio-redis-prod portfolio-workfolio-prod >/dev/null 2>&1 || true
        # And remove any container matching portfolio-*-prod just in case
        CONFLICTING_CONTAINERS=$(docker ps -aq --filter name='^/portfolio-.*-prod$' || true)
        if [ -n "$CONFLICTING_CONTAINERS" ]; then
          echo "Removing lingering containers: $CONFLICTING_CONTAINERS"
          docker rm -f $CONFLICTING_CONTAINERS >/dev/null 2>&1 || true
        fi
        # Small wait to ensure Docker releases names
        sleep 2
        $COMPOSE_CMD -f infrastructure/docker-compose.yml -f infrastructure/prod/docker-compose.prod.yml -f infrastructure/prod/docker-compose.monitoring.prod.yml -f /tmp/compose.images.override.yml -f /tmp/compose.network.override.yml pull || true
        $COMPOSE_CMD -f infrastructure/docker-compose.yml -f infrastructure/prod/docker-compose.prod.yml -f infrastructure/prod/docker-compose.monitoring.prod.yml -f /tmp/compose.images.override.yml -f /tmp/compose.network.override.yml up -d --no-build --pull always
        $COMPOSE_CMD -f infrastructure/docker-compose.yml -f infrastructure/prod/docker-compose.prod.yml -f infrastructure/prod/docker-compose.monitoring.prod.yml -f /tmp/compose.images.override.yml -f /tmp/compose.network.override.yml ps

        echo "Waiting for service health (domain: $DOMAIN_NAME_VALUE) ..."
        for i in $(seq 1 60); do
          ok=0
          curl -fsS -m 5 "https://$DOMAIN_NAME_VALUE/health" >/dev/null 2>&1 && ok=$((ok+1)) || true
          if [ "$ok" -eq 1 ]; then
            echo "Main site endpoint healthy."
            break
          fi
          sleep 5
        done
        if [ "$ok" -ne 1 ]; then
          echo "ERROR: Main site health check failed at https://$DOMAIN_NAME_VALUE" >&2
          exit 1
        fi

        echo "Waiting for monitoring services to become healthy..."
        for i in $(seq 1 60); do
          ok=0
          curl -fsS -m 5 http://localhost:9090/-/healthy >/dev/null 2>&1 && ok=$((ok+1)) || true
          curl -fsS -m 5 http://localhost:3000/api/health >/dev/null 2>&1 && ok=$((ok+1)) || true
          if [ "$ok" -eq 2 ]; then
            echo "Monitoring services healthy (Prometheus and Grafana)."
            break
          fi
          sleep 5
        done
        if [ "$ok" -ne 2 ]; then
          echo "ERROR: Monitoring health checks failed (Prometheus or Grafana)" >&2
          exit 1
        fi

        echo "Disk usage after cleanup:" && df -h /
        echo "Docker disk usage after cleanup:" && docker system df || true

        echo "Ensuring daily cert renewal cron job exists..."
        CRON_LINE="0 3 * * * bash -lc 'PROJECT_DIR=\"$HOME/personal-website\" $HOME/personal-website/infrastructure/prod/renew-ssl.sh >> $HOME/personal-website/infrastructure/logs/certbot/cron.log 2>&1'"
        (crontab -l 2>/dev/null || true) | grep -F "$HOME/personal-website/infrastructure/prod/renew-ssl.sh" >/dev/null 2>&1 || \
        ( (crontab -l 2>/dev/null; echo "$CRON_LINE") | crontab - )
        echo "Cron entry ensured."
        RSCRIPT

        SSH_OPTS="-i ~/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=60 -o ConnectionAttempts=3 -o ServerAliveInterval=15 -o ServerAliveCountMax=4 -o PreferredAuthentications=publickey -o PubkeyAuthentication=yes -o IPQoS=none"

        # Pass environment variables to remote script via SSH
        # These will be available as $GHCR_TOKEN, $GHCR_USERNAME, $REPO, $SHA in the remote script
        # Use double quotes so GitHub Actions substitutions are properly passed to bash
        success=""
        for attempt in 1 2 3; do
          echo "SSH attempt $attempt..."
          if ssh -T $SSH_OPTS -p "$PORT" "$USER@$HOST" \
            GHCR_TOKEN="${{ inputs.ghcr_token }}" \
            GHCR_USERNAME="${{ inputs.ghcr_username }}" \
            REPO="${{ inputs.repository }}" \
            SHA="${{ inputs.sha }}" \
            bash -s < /tmp/remote_deploy.sh; then
            success="yes"; break
          fi
          echo "SSH attempt $attempt failed. Retrying in 15s..."
          sleep 15
        done

        if [ -z "$success" ]; then
          echo "Final SSH attempt with verbose logging (-vvv) for diagnostics:" >&2
          echo "Printing remote SSH banner via netcat for diagnostics (if available)" >&2
          if command -v nc >/dev/null 2>&1; then
            nc -v -w 5 "$HOST" "$PORT" </dev/null || true
          fi
          ssh -vvv -T $SSH_OPTS -p "$PORT" "$USER@$HOST" \
            GHCR_TOKEN="${{ inputs.ghcr_token }}" \
            GHCR_USERNAME="${{ inputs.ghcr_username }}" \
            REPO="${{ inputs.repository }}" \
            SHA="${{ inputs.sha }}" \
            bash -s < /tmp/remote_deploy.sh || true
          exit 1
        fi
