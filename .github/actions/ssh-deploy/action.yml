name: SSH Deploy
description: Deploy to the production server over SSH with cleanup, network setup, and Docker Compose
inputs:
  host:
    description: Production host
    required: true
  user:
    description: SSH username
    required: true
  port:
    description: SSH port
    required: true
  ssh_key:
    description: SSH private key (ed25519)
    required: true
  ghcr_username:
    description: GHCR username
    required: true
  ghcr_token:
    description: GHCR token
    required: true
  repository:
    description: owner/repo for images
    required: true
  sha:
    description: Git SHA to deploy
    required: true
runs:
  using: composite
  steps:
    - name: Configure SSH
      shell: bash
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        # Support both raw OpenSSH key and base64-encoded key in secret
        KEY_RAW="${{ inputs.ssh_key }}"
        # Detect plaintext OpenSSH key; use -- to prevent grep from treating dashes as options
        if printf "%s" "$KEY_RAW" | grep -q -- "BEGIN OPENSSH PRIVATE KEY"; then
          # Looks like a PEM/OpenSSH key; normalize newlines
          printf "%s" "$KEY_RAW" | sed 's/\\n/\n/g' > ~/.ssh/id_ed25519
        else
          # Try base64 decode first; fallback to literal write if decode fails
          printf "%s" "$KEY_RAW" | tr -d '\r' | base64 -d > ~/.ssh/id_ed25519 2>/dev/null || true
          if ! grep -q -- "BEGIN OPENSSH PRIVATE KEY" ~/.ssh/id_ed25519 2>/dev/null; then
            printf "%s" "$KEY_RAW" | sed 's/\\n/\n/g' > ~/.ssh/id_ed25519
          fi
        fi
        chmod 600 ~/.ssh/id_ed25519
        # Quick validation/warning if the key is passphrase-protected or invalid
        if ! ssh-keygen -y -f ~/.ssh/id_ed25519 >/dev/null 2>&1; then
          echo "WARNING: SSH key appears invalid or passphrase-protected. Ensure an unencrypted OpenSSH ed25519 private key is provided in secrets." >&2
          echo "Key header (first line): $(head -n1 ~/.ssh/id_ed25519 2>/dev/null || echo 'N/A')" >&2
        fi
        # Best-effort host key prefetch; do not fail if host is unreachable
        ssh-keyscan -T 10 -p "${{ inputs.port }}" "${{ inputs.host }}" >> ~/.ssh/known_hosts 2>/dev/null || true

    - name: Deploy over SSH
      shell: bash
      run: |
        HOST_RAW='${{ inputs.host }}'
        USER_RAW='${{ inputs.user }}'
        PORT_RAW='${{ inputs.port }}'
        HOST=$(printf "%s" "$HOST_RAW" | tr -d ' \t\r\n')
        USER=$(printf "%s" "$USER_RAW" | tr -d ' \t\r\n')
        PORT=$(printf "%s" "$PORT_RAW" | tr -d ' \t\r\n')
        if [ -z "$PORT" ]; then PORT=22; fi

        echo "Resolving host: $HOST"
        (getent hosts "$HOST" || nslookup -timeout=5 "$HOST" || dig +short "$HOST") 2>/dev/null || true

        echo "Checking TCP connectivity to $HOST:$PORT"
        if command -v nc >/dev/null 2>&1; then
          nc -zv -w 10 "$HOST" "$PORT" || true
        else
          (echo > "/dev/tcp/$HOST/$PORT") >/dev/null 2>&1 || true
        fi

        # Prepare remote script once, then stream it to SSH (allows retries)
        cat > /tmp/remote_deploy.sh << 'RSCRIPT'
        set -e
        cd "$HOME/personal-website"

        echo "Disk usage before cleanup:" && df -h /
        echo "Docker disk usage before cleanup:" && docker system df || true
        docker container prune -f || true
        docker image prune -af || true
        docker builder prune -af || true
        docker network prune -f || true
        docker volume prune -f || true
        sudo find /var/lib/docker/containers -type f -name "*json.log" -size +100M -exec truncate -s 0 {} \; 2>/dev/null || true
        sudo journalctl --vacuum-size=100M 2>/dev/null || true

        DOCKER_CONFIG_DIR="$(mktemp -d -t docker-config-XXXXXX 2>/dev/null || echo /tmp/docker-config)"
        export DOCKER_CONFIG="$DOCKER_CONFIG_DIR"
        echo "${{ inputs.ghcr_token }}" | docker login ghcr.io -u "${{ inputs.ghcr_username }}" --password-stdin

        export WORKFOLIO_IMAGE=ghcr.io/${{ inputs.repository }}/workfolio:${{ inputs.sha }}
        export AI_BACKEND_IMAGE=ghcr.io/${{ inputs.repository }}/ai-backend:${{ inputs.sha }}
        export ARACHNE_IMAGE=ghcr.io/${{ inputs.repository }}/arachne:${{ inputs.sha }}

        echo "Pre-pulling images to ensure availability..."
        MISSING="0"
        docker pull "$WORKFOLIO_IMAGE" || MISSING="1"
        docker pull "$AI_BACKEND_IMAGE" || MISSING="1"
        docker pull "$ARACHNE_IMAGE" || MISSING="1"
        if [ "$MISSING" = "1" ]; then
          echo "ERROR: One or more images are missing in GHCR for SHA ${{ inputs.sha }}. Ensure the CI build-and-push job completed successfully." >&2
          exit 1
        fi

        if [ -f infrastructure/prod/.env ]; then
          echo "Loading environment from infrastructure/prod/.env"
          set -a; . infrastructure/prod/.env; set +a
        else
          echo "WARNING: infrastructure/prod/.env not found; continuing without extra env" >&2
        fi

        docker network create portfolio-network-prod >/dev/null 2>&1 || true
        cat > /tmp/compose.network.override.yml << 'OVR'
        networks:
          portfolio-network-prod:
            external: true
            name: portfolio-network-prod
        OVR

        if command -v docker-compose >/dev/null 2>&1; then COMPOSE_CMD="docker-compose"; else COMPOSE_CMD="docker compose"; fi
        $COMPOSE_CMD -f infrastructure/docker-compose.yml -f infrastructure/prod/docker-compose.prod.yml -f /tmp/compose.network.override.yml pull || true
        $COMPOSE_CMD -f infrastructure/docker-compose.yml -f infrastructure/prod/docker-compose.prod.yml -f /tmp/compose.network.override.yml up -d --no-build --pull always
        $COMPOSE_CMD -f infrastructure/docker-compose.yml -f infrastructure/prod/docker-compose.prod.yml -f /tmp/compose.network.override.yml ps

        echo "Disk usage after cleanup:" && df -h /
        echo "Docker disk usage after cleanup:" && docker system df || true
        RSCRIPT

        SSH_OPTS="-i ~/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=60 -o ConnectionAttempts=3 -o ServerAliveInterval=15 -o ServerAliveCountMax=4 -o PreferredAuthentications=publickey -o PubkeyAuthentication=yes -o IPQoS=none"

        success=""
        for attempt in 1 2 3; do
          echo "SSH attempt $attempt..."
          if ssh -T $SSH_OPTS -p "$PORT" "$USER@$HOST" bash -s < /tmp/remote_deploy.sh; then
            success="yes"; break
          fi
          echo "SSH attempt $attempt failed. Retrying in 15s..."
          sleep 15
        done

        if [ -z "$success" ]; then
          echo "Final SSH attempt with verbose logging (-vvv) for diagnostics:" >&2
          echo "Printing remote SSH banner via netcat for diagnostics (if available)" >&2
          if command -v nc >/dev/null 2>&1; then
            nc -v -w 5 "$HOST" "$PORT" </dev/null || true
          fi
          ssh -vvv -T $SSH_OPTS -p "$PORT" "$USER@$HOST" bash -s < /tmp/remote_deploy.sh || true
          exit 1
        fi


