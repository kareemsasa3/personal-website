name: CD - Deploy to Production

on:
  workflow_run:
    workflows: ["Build & Publish Images"]
    types:
      - completed

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  deploy:
    # This job only runs if the CI workflow was successful on the main/master branch
    if: ${{ github.event.workflow_run.conclusion == 'success' && (github.event.workflow_run.head_branch == 'main' || github.event.workflow_run.head_branch == 'master') }}
    runs-on: ubuntu-latest
    permissions:
      contents: read # Required to checkout the repo and read the composite action
      packages: read # Required for GHCR login, though token handles auth
    env:
      PROD_DOMAIN: ${{ secrets.PROD_DOMAIN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # No fetch-depth needed as we get the SHA from the workflow_run event

      # The composite action now handles all SSH and deployment logic.
      # The old "Configure SSH" and "Set image tags env" steps are no longer needed.
      - name: Write SSH key and add host
        run: |
          mkdir -p ~/.ssh
          umask 077
          KEY_CONTENT="${{ secrets.PROD_SSH_KEY }}"
          # First attempt: write as-is (supports proper multiline secrets)
          printf '%s' "$KEY_CONTENT" | tr -d '\r' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          if ! ssh-keygen -y -f ~/.ssh/deploy_key > /dev/null 2>&1; then
            # Fallback 1: interpret escaped newlines (e.g. \n) found in some secret setups
            printf '%b' "$KEY_CONTENT" | tr -d '\r' > ~/.ssh/deploy_key
            chmod 600 ~/.ssh/deploy_key
          fi
          if ! ssh-keygen -y -f ~/.ssh/deploy_key > /dev/null 2>&1; then
            # Fallback 2: treat secret as base64 encoded key
            echo "$KEY_CONTENT" | base64 -d > ~/.ssh/deploy_key 2>/dev/null || true
            chmod 600 ~/.ssh/deploy_key
          fi
          # Final validation
          ssh-keygen -y -f ~/.ssh/deploy_key > /dev/null 2>&1 || { echo "Invalid SSH key format" >&2; exit 1; }
          ssh-keyscan -p ${{ secrets.PROD_PORT }} ${{ secrets.PROD_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy via SSH (no .env sourcing; use compose --env-file)
        env:
          HOST: ${{ secrets.PROD_HOST }}
          USER: ${{ secrets.PROD_USER }}
          PORT: ${{ secrets.PROD_PORT }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          REPO: ${{ github.repository }}
          SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          ssh -i ~/.ssh/deploy_key -p "$PORT" "$USER@$HOST" bash -se << EOSSH
          set -euo pipefail
          REPO="${REPO}"
          SHA="${SHA}"
          GHCR_USERNAME="${GHCR_USERNAME}"
          GHCR_TOKEN="${GHCR_TOKEN}"
          WORKDIR="\$HOME/personal-website"
          mkdir -p "\$WORKDIR"
          # Fetch exact commit contents without needing git credentials
          if ! curl -fsSL "https://codeload.github.com/\${REPO}/tar.gz/\${SHA}" | tar -xz -C "\$WORKDIR" --strip-components=1; then
            echo "Falling back to main branch archive"
            curl -fsSL "https://codeload.github.com/\${REPO}/tar.gz/refs/heads/main" | tar -xz -C "\$WORKDIR" --strip-components=1
          fi
          cd "\$WORKDIR/infrastructure/prod"
          # Ensure prod uses root env file but do NOT source it
          ln -sf ../.env .env
          echo "\$GHCR_TOKEN" | docker login ghcr.io -u "\$GHCR_USERNAME" --password-stdin
          export WORKFOLIO_IMAGE=ghcr.io/\${REPO}/workfolio:\${SHA}
          export AI_BACKEND_IMAGE=ghcr.io/\${REPO}/ai-backend:\${SHA}
          export ARACHNE_IMAGE=ghcr.io/\${REPO}/arachne:\${SHA}
          export ARACHNE_CPU_LIMIT=1.0
          # Ensure external prod network exists (idempotent)
          docker network create portfolio-network-prod >/dev/null 2>&1 || true
          # Bring down current prod stack (if any) to avoid port/cpu conflicts
          docker compose --env-file ../.env -f docker-compose.prod.yml -f docker-compose.monitoring.prod.yml down --remove-orphans || true
          # Cleanup any legacy containers by name (from previous compose files)
          docker ps -aq --filter name='^portfolio-.*' | xargs -r docker rm -f || true
          # Aggressive cleanup to free disk before pulling new images (keeps volumes)
          echo "Before prune:"
          docker system df || true
          docker system prune -af || true
          docker builder prune -af || true
          echo "After prune:"
          docker system df || true
          # Ensure external prod network exists (again) right before up
          docker network create portfolio-network-prod >/dev/null 2>&1 || true
          # Bring up services with fresh images, remove orphans, and force recreate (app + monitoring)
          docker compose --env-file ../.env -f docker-compose.prod.yml -f docker-compose.monitoring.prod.yml up -d --pull always --remove-orphans --force-recreate nginx workfolio ai-backend arachne prometheus grafana grafana-admin node-exporter nginx-exporter redis-exporter
          EOSSH

      - name: Verify monitoring health (via SSH)
        env:
          HOST: ${{ secrets.PROD_HOST }}
          USER: ${{ secrets.PROD_USER }}
          PORT: ${{ secrets.PROD_PORT }}
        run: |
          ssh -i ~/.ssh/deploy_key -p "$PORT" "$USER@$HOST" "bash -se -c 'set -euo pipefail; echo Waiting for Prometheus and Grafana to become healthy...; for i in \$(seq 1 60); do ok=0; curl -fsS -m 5 http://localhost:9090/-/healthy >/dev/null && ok=\$((ok+1)) || true; curl -fsS -m 5 http://localhost:3000/api/health >/dev/null && ok=\$((ok+1)) || true; if [ \"\$ok\" -eq 2 ]; then echo Monitoring healthy.; exit 0; fi; sleep 5; done; echo ERROR: Monitoring health checks failed >&2; exit 1'"

      - name: Verify production health
        if: ${{ env.PROD_DOMAIN != '' }}
        env:
          DOMAIN: ${{ env.PROD_DOMAIN }}
        run: |
          set -e
          echo "Waiting for services at https://$DOMAIN ..."
          for i in {1..60}; do
            ok=0
            curl -fsS -m 5 "https://$DOMAIN/health" >/dev/null && ok=$((ok+1)) || true
            curl -fsS -m 5 "https://$DOMAIN/api/ai/health" >/dev/null && ok=$((ok+1)) || true
            curl -fsS -m 5 "https://$DOMAIN/api/arachne/health" >/dev/null && ok=$((ok+1)) || true
            # Grafana proxied under subpath
            curl -fsS -m 5 "https://$DOMAIN/monitoring/grafana/api/health" >/dev/null && ok=$((ok+1)) || true
            if [ "$ok" -eq 4 ]; then
              echo "All endpoints healthy."
              exit 0
            fi
            sleep 5
          done
          echo "ERROR: One or more health checks failed at https://$DOMAIN" >&2
          exit 1
