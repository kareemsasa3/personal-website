name: CD - Deploy to Production

on:
  workflow_run:
    workflows: ["Build & Publish Images"]
    types:
      - completed

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  deploy:
    # This job only runs if the CI workflow was successful on the main/master branch
    if: ${{ github.event.workflow_run.conclusion == 'success' && (github.event.workflow_run.head_branch == 'main' || github.event.workflow_run.head_branch == 'master') }}
    runs-on: ubuntu-latest
    permissions:
      contents: read # Required to checkout the repo and read the composite action
      packages: read # Required for GHCR login, though token handles auth

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # No fetch-depth needed as we get the SHA from the workflow_run event

      # The composite action now handles all SSH and deployment logic.
      # The old "Configure SSH" and "Set image tags env" steps are no longer needed.
      - name: Export PROD_DOMAIN to environment
        run: |
          if [ -z "${{ secrets.PROD_DOMAIN }}" ]; then
            echo "PROD_DOMAIN=" >> $GITHUB_ENV
          else
            echo "PROD_DOMAIN=${{ secrets.PROD_DOMAIN }}" >> $GITHUB_ENV
          fi

      - name: Write SSH key and add host
        run: |
          mkdir -p ~/.ssh
          umask 077
          printf "%s" '${{ secrets.PROD_SSH_KEY }}' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p ${{ secrets.PROD_PORT }} ${{ secrets.PROD_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy via SSH (no .env sourcing; use compose --env-file)
        env:
          HOST: ${{ secrets.PROD_HOST }}
          USER: ${{ secrets.PROD_USER }}
          PORT: ${{ secrets.PROD_PORT }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          REPO: ${{ github.repository }}
          SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          ssh -i ~/.ssh/deploy_key -p "$PORT" "$USER@$HOST" bash -se << 'EOSSH'
          set -euo pipefail
          cd /opt/personal-website
          git pull --ff-only || true
          cd infrastructure/prod
          # Ensure prod uses root env file but do NOT source it
          ln -sf ../.env .env
          echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
          export WORKFOLIO_IMAGE=ghcr.io/$REPO/workfolio:$SHA
          export AI_BACKEND_IMAGE=ghcr.io/$REPO/ai-backend:$SHA
          export ARACHNE_IMAGE=ghcr.io/$REPO/arachne:$SHA
          docker compose --env-file ../.env -f docker-compose.prod.yml up -d --pull always nginx ai-backend arachne
          EOSSH

      - name: Verify production health
        if: ${{ env.PROD_DOMAIN != '' }}
        env:
          DOMAIN: ${{ env.PROD_DOMAIN }}
        run: |
          set -e
          echo "Waiting for services at https://$DOMAIN ..."
          for i in {1..60}; do
            ok=0
            curl -fsS -m 5 "https://$DOMAIN/health" >/dev/null && ok=$((ok+1)) || true
            curl -fsS -m 5 "https://$DOMAIN/api/ai/health" >/dev/null && ok=$((ok+1)) || true
            curl -fsS -m 5 "https://$DOMAIN/api/arachne/health" >/dev/null && ok=$((ok+1)) || true
            if [ "$ok" -eq 3 ]; then
              echo "All endpoints healthy."
              exit 0
            fi
            sleep 5
          done
          echo "ERROR: One or more health checks failed at https://$DOMAIN" >&2
          exit 1
